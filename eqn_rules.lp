% Armando Diaz Tolentino <ajdt@cs.washington.edu> 
% 
% This file contains all the rules used to solve an equation
% generated by eqn_generator.lp
%
% each rule's section contains both the condtions for the rule to fire,
% and the actions to perform if the rule is fired.
%
% XXX: these rules no longer check the types of  N1, C1, and C2. Types are implicit depending on nodeDeg, nodeOper, etc... predicates that hold


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% USEFUL CONSTANTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Constant one.
% NOTE: to set a node to 1, just have it "inheritFrom" this node, and set depth/side manually
node(one).
type(one, mono).
nodeCoef(one,1). 
nodeDeg(one,0).  

% move these to solver later
sameDeg(N1, N2, S) :- holds(N1, field(nodeDeg, Deg), S), holds(N2, field(nodeDeg, Deg), S).
sameCoef(N1, N2, S) :- holds(N1, field(nodeCoef, Coef), S), holds(N2, field(nodeCoef, Coef), S).
%================================================================================
% addCommonTerms: a*x^b + c*x^b ----> (a+c)*x^b, 2 Cases
%================================================================================
% 						### RULE CONDITIONS ###
% there's an add poly node with two children that are monomials of the same degree
possible(action(data(N1, C1, C2), addCommTerms), S) 	:- 	holds(N1, field(nodeOper,add), S),
															holds(N1, field(parentOf,C1), S),
															holds(N1, field(parentOf,C2), S),
															sameDeg(C1, C2, S),
															C1 != C2.
% 						### APPLYING THE RULE ###
% 						### CASE 1: parent node has more than 2 children ###
% add the two nodes together
update(C1, field(nodeCoef,Coef1 + Coef2), S) 	:-	_selected(action(data(N1, C1, C2), addCommTerms), S),
													holds(N1, field(numChildren,Kids), S), Kids > 2,
													holds(C1, field(nodeCoef, Coef1), S),
													holds(C2, field(nodeCoef, Coef2), S).
% decrement number of children
update(N1, field(numChildren,Kids - 1), S) 	:-	_selected(action(data(N1, C1, C2), addCommTerms), S),
												holds(N1, field(numChildren,Kids), S), Kids > 2.

% 						### CASE 2: parent node has exactly 2 children ###
%--------------------------------------------------------------------------------
% 								so parent node becomes monomial.
% NOTE: cannot use inheritFrom here b/c coefficient isn't directly inherited. 
% remove old facts about parent
delete(N1, S) 									:-	_selected(action(data(N1, C1, C2), addCommTerms), S),
													holds(N1, field(numChildren,2), S).
% parent ID becomes a monomial, and gains node parameters
assigned(N1, field(type,mono), S) 				:-	_selected(action(data(N1, C1, C2), addCommTerms), S),
													holds(N1, field(numChildren,2), S).
assigned(N1, field(nodeCoef,Coef1+ Coef2), S) 	:-	_selected(action(data(N1, C1, C2), addCommTerms), S),
													holds(N1, field(numChildren,2), S),
													holds(C1, field(nodeCoef, Coef1), S),
													holds(C2, field(nodeCoef, Coef2), S).
assigned(N1, field(nodeDeg,Degree), S) 			:-	_selected(action(data(N1, C1, C2), addCommTerms), S),
													holds(N1, field(numChildren,2), S),
													holds(C1, field(nodeDeg,Degree), S) .
% C1 child node is deleted 
deleteChild(N1, C1, S)							:-	_selected(action(data(N1, C1, C2), addCommTerms), S),
													holds(N1, field(numChildren,2), S).

%						### BOTH CASES ###
%--------------------------------------------------------------------------------
% completely erase second node											
deleteChild(N1, C2)		:-	_selected(action(data(N1, C1, C2), addCommTerms), S).
%================================================================================
%================================================================================


%================================================================================
% addIdentity: a*x^b + 0 ----> a*x^b 
%================================================================================
% 						### RULE CONDITIONS ###
% TODO: refactor action data from actions!
% there's an add poly node with two children that are monomials, one of them has coef == 0 
% the only info we remember is the identity of the parent node and the node to remove
possible(action(data(N1, C1, C2), addIdent), S) 	:- 	holds(N1, field(nodeOper,add), S),
														holds(N1, field(parentOf,C1), S),
														holds(N1, field(parentOf,C2), S),
														holds(C2, field(nodeCoef,0), S),
														C1 != C2.
% 						### APPLYING THE RULE ###
% shrink subtree by removing the zero node
shrinkSubtree(N1, ZeroNode, S)					:-	_selected(action(data(N1, C1, ZeroNode), addIdent), S).
%================================================================================
%================================================================================



%================================================================================
% divideInverse: a*x^b / a*x^b ----> 1
%================================================================================
% 						### RULE CONDITIONS ###
% There's a div node with two children that are equal
possible(action(data(N1, C1, C2), divInverse), S) 	:- 	holds(N1, field(nodeOper,div), S),
														holds(N1, field(parentOf,C1), S),
														holds(N1, field(parentOf,C2), S),
														sameDeg(C1, C2, S),
														sameCoef(C1, C2, S),
														C1 != C2.

% 						### APPLYING THE RULE ###
%--------------------------------------------------------------------------------

% parent becomes monomial with value 1, we must manually set its side value
inheritFrom(N1, one, S) 			:-	_selected(action(data(N1, C1, C2), divInverse), S). 
assigned(N1, field(side,Side), S) 	:-	_selected(action(data(N1, C1, C2), divInverse), S),
										holds(N1, field(side,Side), S).

% completely erase both children
deleteChild(N1, C1, S) 					:-	_selected(action(data(N1, C1, C2), divInverse), S).
deleteChild(N1, C2, S) 					:-	_selected(action(data(N1, C1, C2), divInverse), S).
%================================================================================
%================================================================================



%================================================================================
% multIdentity: a*x^b * 1 ----> a*x^b
%================================================================================
% 						### RULE CONDITIONS ###
% There's a div node with two children that are equal
possible(action(data(N1, C1, C2), multIdent), S) 	:- 	holds(N1, field(nodeOper,mul), S),
											holds(N1, field(parentOf,C1), S),
											holds(N1, field(parentOf,C2), S),
											holds(C2, field(nodeCoef,1), S),
											holds(C2, field(nodeDeg,0), S),
											C1 != C2.

% 						### APPLYING THE RULE ###
% shrink the subtree by removing the child with value 1
shrinkSubtree(N1, NodeOne, S)					:-	_selected(action(data(N1, C1, NodeOne), multIdent), S).
%================================================================================
%================================================================================
