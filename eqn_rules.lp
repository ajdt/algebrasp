% Armando Diaz Tolentino <ajdt@cs.washington.edu> 
% 
% This file contains all the rules used to solve an equation
% generated by eqn_generator.lp
%
% each rule's section contains both the condtions for the rule to fire,
% and the actions to perform if the rule is fired.
%
% XXX: these rules no longer check the types of  N1, C1, and C2. Types are implicit depending on nodeDeg, nodeOper, etc... predicates that hold


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% USEFUL CONSTANTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Constant one.
% NOTE: to set a node to 1, just have it "inheritFrom" this node, and set depth/side manually
node(one).
type(one, mono).
nodeCoef(one,1). 
nodeDeg(one,0).  

%================================================================================
% addCommonTerms: a*x^b + c*x^b ----> (a+c)*x^b, 2 Cases
%================================================================================
% 						### RULE CONDITIONS ###
% there's an add poly node with two children that are monomials of the same degree
possible(action(data(N1, C1, C2, Coef1+Coef2), addCommTerms), S) 	:- 	holds(N1, field(nodeOper,add), S),
											holds(N1, field(parentOf,C1), S),
											holds(N1, field(parentOf,C2), S),
											holds(C1, field(nodeDeg,Deg), S),
											holds(C2, field(nodeDeg,Deg), S),
											holds(C1, field(nodeCoef,Coef1), S),
											holds(C2, field(nodeCoef,Coef2), S),
											Coef1 != 0,% remove
											Coef2 != 0,% remove
											C1 != C2.
% 						### APPLYING THE RULE ###
% 						### CASE 1: parent node has more than 2 children ###
% add the two nodes together
assigned(C1, field(nodeCoef,Sum), S) 			:-	_selected(action(data(N1, C1, C2, Sum), addCommTerms), S),
											holds(N1, field(numChildren,Kids), S), Kids > 2.
% decrement number of children
assigned(N1, field(numChildren,Kids - 1), S) 	:-	_selected(action(data(N1, C1, C2, Sum), addCommTerms), S),
											holds(N1, field(numChildren,Kids), S), Kids > 2.


% 						### CASE 2: parent node has exactly 2 children ###
%--------------------------------------------------------------------------------
% 								so parent node becomes monomial.
% TODO: cannot use inheritFrom here b/c coefficient isn't directly inherited. 
% remove old facts about parent
removed(N1, Fact, S) 				:-	_selected(action(data(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, field(numChildren,Kids), S), Kids == 2,
										holds(C2, Fact, S).
% parent ID is still a node, becomes a monomial, and gains node parameters
assigned(N1, field(node,N1), S) 			:-	_selected(action(data(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, field(numChildren,Kids), S), Kids == 2.
assigned(N1, field(type,mono), S) 		:-	_selected(action(data(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, field(numChildren,Kids), S), Kids == 2.
assigned(N1, field(nodeCoef,Sum), S) 		:-	_selected(action(data(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, field(numChildren,Kids), S), Kids == 2.
assigned(N1, field(nodeDeg,Degree), S) 	:-	_selected(action(data(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, field(numChildren,Kids), S), Kids == 2,
										holds(C1, field(nodeDeg,Degree), S) .
% C1 child node is deleted 
removed(C1, Fact, S)				:-	_selected(action(data(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, field(numChildren,Kids), S), Kids == 2,
										holds(C1, Fact, S).

%						### BOTH CASES ###
%--------------------------------------------------------------------------------
% completely erase second node											
removed(C2, Fact, S)	:-	_selected(action(data(N1, C1, C2, Sum), addCommTerms), S),
							holds(C2, Fact, S).
%================================================================================
%================================================================================


%================================================================================
% addIdentity: a*x^b + 0 ----> a*x^b 
%================================================================================
% 						### RULE CONDITIONS ###
% TODO: refactor action data from actions!
% there's an add poly node with two children that are monomials, one of them has coef == 0 
% the only info we remember is the identity of the parent node and the node to remove
possible(action(data(N1, C1, C2), addIdent), S) 	:- 	holds(N1, field(nodeOper,add), S),
											holds(N1, field(parentOf,C1), S),
											holds(N1, field(parentOf,C2), S),
											holds(C1, field(nodeCoef,Coef1), S),
											holds(C2, field(nodeCoef,0), S),
											C1 != C2.
% 						### APPLYING THE RULE ###
% 						### CASE 1: parent node has more than 2 children ###
% decrement number of children
assigned(N1, field(numChildren,Kids - 1), S) 	:-	_selected(action(data(N1, C1, C2), addIdent), S),
											holds(N1, field(numChildren,Kids), S), Kids > 2.


% 						### CASE 2: parent node has exactly 2 children ###
%--------------------------------------------------------------------------------

% parent inherits C1 child's properities
inheritFrom(N1, C1, S) :-	_selected(action(data(N1, C1, C2), addIdent), S), 
										holds(N1, field(numChildren,Kids), S), Kids == 2.
% C1 child node is deleted 
removed(C1, Fact, S)				:-	_selected(action(data(N1, C1, C2), addIdent), S),
										holds(N1, field(numChildren,Kids), S), Kids == 2,
										holds(C1, Fact, S).

%						### BOTH CASES ###
%--------------------------------------------------------------------------------
% completely erase second node											
removed(C2, Fact, S)	:-	_selected(action(data(N1, C1, C2), addIdent), S),
							holds(C2, Fact, S).
%================================================================================
%================================================================================

%================================================================================
% divideInverse: a*x^b / a*x^b ----> 1
%================================================================================
% 						### RULE CONDITIONS ###
% There's a div node with two children that are equal
possible(action(data(N1, C1, C2), divInverse), S) 	:- 	holds(N1, field(nodeOper,div), S),
											holds(N1, field(parentOf,C1), S),
											holds(N1, field(parentOf,C2), S),
											holds(C1, field(nodeCoef,Coef), S),
											holds(C2, field(nodeCoef,Coef), S),
											holds(C1, field(nodeDeg,Deg), S),
											holds(C2, field(nodeDeg,Deg), S),
											C1 != C2.

% 						### APPLYING THE RULE ###
%--------------------------------------------------------------------------------

% parent becomes monomial with value 1, we must manually set the side and depth values
inheritFrom(N1, one, S) 		:-	_selected(action(data(N1, C1, C2), divInverse), S). 
assigned(N1, field(depth,Depth), S)	:-	_selected(action(data(N1, C1, C2), divInverse), S),
									holds(N1, field(depth,Depth), S).
assigned(N1, field(side,Side), S) 	:-	_selected(action(data(N1, C1, C2), divInverse), S),
									holds(N1, field(side,Side), S).

% completely erase both children
removed(C1, Fact, S)			:-	_selected(action(data(N1, C1, C2), divInverse), S),
									holds(C1, Fact, S).
removed(C2, Fact, S)			:-	_selected(action(data(N1, C1, C2), divInverse), S),
									holds(C2, Fact, S).
%================================================================================
%================================================================================



%================================================================================
% multIdentity: a*x^b * 1 ----> a*x^b
%================================================================================
% 						### RULE CONDITIONS ###
% There's a div node with two children that are equal
possible(action(data(N1, C1, C2), multIdent), S) 	:- 	holds(N1, field(nodeOper,mul), S),
											holds(N1, field(parentOf,C1), S),
											holds(N1, field(parentOf,C2), S),
											holds(C1, field(nodeCoef,Coef), S),
											holds(C2, field(nodeCoef,1), S),
											holds(C2, field(nodeDeg,0), S),
											C1 != C2.

% 						### APPLYING THE RULE ###
% 						### CASE 1: parent node has more than 2 children ###
% decrement number of children
removed(N1, field(numChildren,Kids), S) 		:-	_selected(action(data(N1, C1, C2), multIdent), S),
											holds(N1, field(numChildren,Kids), S), Kids > 2.
assigned(N1, field(numChildren,Kids - 1), S) 	:-	_selected(action(data(N1, C1, C2), multIdent), S),
											holds(N1, field(numChildren,Kids), S), Kids > 2.


% 						### CASE 2: parent node has exactly 2 children ###
%--------------------------------------------------------------------------------

% parent inherits C1 child's properities
inheritFrom(N1, C1, S) 					:-	_selected(action(data(N1, C1, C2), multIdent), S), 
											holds(N1, field(numChildren,Kids), S), Kids == 2.
% C1 child node is deleted 
removed(C1, Fact, S)					:-	_selected(action(data(N1, C1, C2), multIdent), S),
											holds(N1, field(numChildren,Kids), S), Kids == 2,
											holds(C1, Fact, S).

%						### BOTH CASES ###
%--------------------------------------------------------------------------------
% completely erase second node											
removed(C2, Fact, S)	:-	_selected(action(data(N1, C1, C2), multIdent), S),
							holds(C2, Fact, S).
%================================================================================
%================================================================================
