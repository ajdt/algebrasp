% Armando Diaz Tolentino <ajdt@cs.washington.edu> 
% 
% This file encodes a solver for the equations
% generated by eqn_generator.lp
%

#const max_steps = 1. % max number of actions until a solution is reached
step(0..max_steps). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EQN STATES AT GIVEN STEP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% all of the facts created by eqn_generator initially hold 
initially(N, node(N))				:-	node(N).
initially(ID, type(T))				:-	type(ID,T).
initially(ID, nodeOper(Op))			:-	nodeOper(ID,Op).
initially(ID, numChildren(Num))		:-	numChildren(ID,Num).
initially(PID, parentOf(CID))		:-	parentOf(PID, CID).
initially(ID, side(S))				:-	side(ID, S).
initially(ID, depth(D))				:-	depth(ID, D).
initially(ID, nodeCoef(C))			:-	nodeCoef(ID, C).
initially(ID, nodeDeg(D))			:-	nodeDeg(ID, D).


% all initial facts hold at step zero
holds(ID, Fact, 0)		:-	initially(ID, Fact).


% every fact that isn't removed at step S, holds at the next step
holds(ID, Fact, S+1)	:-	holds(ID, Fact, S), not removed(ID, Fact, S), step(S+1).
holds(ID, Fact, S+1)	:-	assigned(ID, Fact, S), step(S+1). % new fact that is generated

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% RULE SELECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% possible actions:
%	each possible action is valid at a particular point in time
%	possible(action, S)
%
%	TODO: need a convenient way to factor out the actions that will be done if
%	a candidate action is selected
%
%   for every possible action, we select one action to be performed
% 	then for the performed action, we follow the required steps

% rule: a*x^b + c*x^b ==> (a+c)*x^b
possible(action(addCommonTerms(N1, C1, C2, Coef1+Coef2), addCommTerms), S) 	:- 	holds(N1, node(N1), S), 
											holds(N1, type(poly), S),
											holds(N1, nodeOper(add), S),
											holds(N1, parentOf(C1), S),
											holds(N1, parentOf(C2), S),
											holds(C1, type(mono), S),
											holds(C2, type(mono), S),
											holds(C1, nodeDeg(Deg), S),
											holds(C2, nodeDeg(Deg), S),
											holds(C1, nodeCoef(Coef1), S),
											holds(C2, nodeCoef(Coef2), S),
											Coef1 != 0,% remove
											Coef2 != 0,% remove
											C1 != C2.
% TODO: refactor action data from actions!
% TODO: find out why this rule is Soooo slow
% do no more than one action per time step
0 { do_action(Action, S) : possible(Action, S) } 1 :- step(S).



% project just on the action name, as opposed to the specific terms the action applies to. 
% later, can project on action occuring at a particular time step: action(Name, Step)
action(Name) :- do_action(action(X,Name), S).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SOLVER RULES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%--------------------------------------------------------------------------------
% addCommonTerms: a*x^b + c*x^b ----> (a+c)*x^b, 2 Cases
%--------------------------------------------------------------------------------
% 						CASE 1: parent node has more than 2 children
% add the two nodes together
assigned(C1, nodeCoef(Sum), S) 			:-	do_action(action(addCommonTerms(N1, C1, C2, Sum), addCommTerms), S),
											holds(N1, numChildren(Kids), S), Kids > 2.
% decrement number of children
assigned(N1, numChildren(Kids - 1), S) 	:-	do_action(action(addCommonTerms(N1, C1, C2)), S),
											holds(N1, numChildren(Kids), S), Kids > 2.


% 						CASE 2: parent node has exactly 2 children
% 								so parent node becomes monomial.
% remove old facts about parent
removed(N1, Fact, S) 				:- 	do_action(action(addCommonTerms(N1, C1, C2)), S),
										holds(N1, numChildren(Kids), S), Kids == 2,
										holds(C2, Fact, S).
% parent ID is still a node, becomes a monomial, and gains node parameters
assigned(N1, node(N1), S) 			:-	do_action(action(addCommonTerms(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, numChildren(Kids), S), Kids == 2.
assigned(N1, type(mono), S) 		:-	do_action(action(addCommonTerms(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, numChildren(Kids), S), Kids == 2.
assigned(N1, nodeCoef(Sum), S) 		:-	do_action(action(addCommonTerms(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, numChildren(Kids), S), Kids == 2.
assigned(N1, nodeDeg(Degree), S) 	:-	do_action(action(addCommonTerms(N1, C1, C2, Sum), addCommTerms), S),
										holds(N1, numChildren(Kids), S), Kids == 2,
										holds(C1, nodeDeg(Degree), S) .
% C1 child node is deleted 
removed(C1, Fact, S)				:-	do_action(action(addCommonTerms(N1, C1, C2)), S),
										holds(N1, numChildren(Kids), S), Kids == 2,
										holds(C1, Fact, S).

%						BOTH CASES
% completely erase second node											
removed(C2, Fact, S)	:-	do_action(action(addCommonTerms(N1, C1, C2)), S),
							holds(C2, Fact, S).
%--------------------------------------------------------------------------------



% TODO: remove this is just for testing:
_node(N)              	:-	node(N).              
_type(ID,T)           	:-	type(ID,T).           
_nodeOper(ID,Op)		:-	nodeOper(ID,Op).     
_numChildren(ID,Num) 	:-	numChildren(ID,Num). 
_parentOf(PID, CID)   	:-	parentOf(PID, CID).   
_side(ID, S)          	:-	side(ID, S).          
_depth(ID, D)         	:-	depth(ID, D).         
_nodeCoef(ID, C)     	:-	nodeCoef(ID, C).     
_nodeDeg(ID, D)      	:-	nodeDeg(ID, D).      


% TODO: remove. Used by eqn visualizer
_node(ID, S)            	:-	holds(ID, node(N), S).			
_type(ID,T, S)				:-	holds(ID, type(T), S).			
_nodeOper(ID,Op, S)			:-	holds(ID, nodeOper(Op), S).		
_numChildren(ID,Num, S)		:-	holds(ID, numChildren(Num), S).	
_parentOf(ID, CID, S)		:-	holds(ID, parentOf(CID), S).	
_side(ID, S, S)				:-	holds(ID, side(S), S).			
_depth(ID, D, S)			:-	holds(ID, depth(D), S).			
_nodeCoef(ID, C, S)			:-	holds(ID, nodeCoef(C), S).		
_nodeDeg(ID, D, S)			:-	holds(ID, nodeDeg(D), S).		

%#show holds/2.
%#show action/1.
#show action/1.
#show _node/1.
#show _type/2.
#show _nodeOper/2.
#show _numChildren/2.
#show _parentOf/2.
#show _side/2.
#show _depth/2.
#show _nodeCoef/2.
#show _nodeDeg/2.

% used for eqn solver steps
#show _node/2.
#show _type/3.
#show _nodeOper/3.
#show _numChildren/3.
#show _parentOf/3.
#show _side/3.
#show _depth/3.
#show _nodeCoef/3.
#show _nodeDeg/3.

