% Armando Diaz Tolentino <ajdt@cs.washington.edu> 
% 
% This file encodes a solver for the equations
% generated by eqn_generator.lp
%
% NOTE: this file depends on eqn_rule for the rules used to solve an equation!

#const max_steps = 3. % max number of actions until a solution is reached
step(0..max_steps). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INITIAL EQN FACTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% all of the facts created by eqn_generator initially hold 
initially(ID, field(numer, Num))			:-	numer(ID,Num).
initially(ID, field(denom, Denom))			:-	denom(ID,Denom).
initially(ID, field(type, T))				:-	type(ID,T).
initially(ID, field(nodeOper, Op))			:-	nodeOper(ID,Op).
initially(ID, field(numChildren, Num))		:-	numChildren(ID,Num).
initially(PID, field(parentOf, CID))		:-	parentOf(PID, CID).
initially(ID, field(side, S))				:-	side(ID, S).
initially(ID, hidden(depth, D))				:-	depth(ID, D). % NOTE: hidden fields are not inherited
initially(ID, field(nodeCoef, C))			:-	nodeCoef(ID, C).
initially(ID, field(nodeDeg, D))			:-	nodeDeg(ID, D).


% all initial facts hold at step zero
holds(ID, Fact, 0)		:-	initially(ID, Fact).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EDITING EQN FACTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Facts can be removed, updated, or assigned at each step, if not, then they carry over from last step.

% every fact that isn't removed at step S, holds at the next step
holds(ID, Fact, S+1)	:-	holds(ID, Fact, S), not removed(ID, Fact, S), step(S+1).
holds(ID, Fact, S+1)	:-	assigned(ID, Fact, S), step(S+1). % new fact that is generated

% 						### UPDATE FACT
%--------------------------------------------------------------------------------
% to update a field means to remove old field and add the new field value
assigned(ID, Fact, S) :- update(ID, Fact, S).
removed(ID, field(Name, OrigValue), S)	:- update(ID, field(Name, Value), S), 
										holds(ID, field(Name, OrigValue), S).

% 						### INHERITING FACTS
%--------------------------------------------------------------------------------
% N1 inherits all field() predicates from C1, not hidden() predicates
% NOTE: DOES NOT remove C1
assigned(N1, field(Name, Value), S)		:- inheritFrom(N1, C1, S), holds(C1, field(Name, Value), S).	% add new facts
removed(N1, field(Name, Value), S)		:- inheritFrom(N1, C1, S), holds(N1, field(Name, Value), S). 	% remove all old facts

% 						### DELETING A NODE
%--------------------------------------------------------------------------------
% abstracted notion of deleting a node
removed(ToDelete, Fact, S)		:-	delete(ToDelete, S),
									holds(ToDelete, Fact, S) .

% 						### DELETE CHILD
%--------------------------------------------------------------------------------
% removes a child and paren'ts reference to it
% NOTE: does not update numChildren counter. This must be done manually
delete(ToDelete, S)								:-	deleteChild(Parent, ToDelete, S).
removed(Parent, fact(parentOf, ToDelete), S)	:-	deleteChild(Parent, ToDelete, S).
									

% 						### SWAPPING NODE VALUES
%--------------------------------------------------------------------------------
% each node will inherit from the other 
inheritFrom(Node1, Node2, S) :- swapValues(Node1, Node2, S).
inheritFrom(Node2, Node1, S) :- swapValues(Node1, Node2, S).

% 						### REMOVING NODE FROM SUBTREE
%--------------------------------------------------------------------------------
% shrinking a subtree by one node!
deleteChild(Parent, ToRemove, S) :- shrinkSubtree(Parent, ToRemove, S).
							
% if have more than two kids, then just decrement num kids
update(Parent, field(numChildren,Kids - 1), S)	:-	shrinkSubtree(Parent, ToRemove, S),
													holds(Parent, field(numChildren,Kids), S), Kids > 2.
% if exactly two kids, then replace remaining child...
inheritFromAndDelete(Parent, SecondKid, S)		:-	shrinkSubtree(Parent, ToRemove, S),
													holds(Parent, field(numChildren,2), S),
													holds(Parent, field(parentOf,SecondKid), S),
													SecondKid != ToRemove.
inheritFrom(Parent, SecondKid, S)				:- inheritFromAndDelete(Parent, SecondKid, S).
deleteChild(Parent, SecondKid, S) 				:- inheritFromAndDelete(Parent, SecondKid, S).

% 						### SHRINK SUBTREE, USE NEW VALUE
%--------------------------------------------------------------------------------
% When an operation is done on child1 and Child2 to yield the fields NewValue has,
% and we wish to replace Child1 and Child2 with NewValue.
% 

deleteChild(Parent, Child2, S) 					:- contractNodes(Parent, Child1, Child2, NewValue, S).
							
% if have more than two kids, then just decrement num kids and replace Child1 with newValue
update(Parent, field(numChildren,Kids - 1), S)	:- contractNodes(Parent, Child1, Child2, NewValue, S),
													holds(Parent, field(numChildren,Kids), S), Kids > 2.
inheritFromAndDelete(Child1, NewValue, S)		:- contractNodes(Parent, Child1, Child2, NewValue, S),
													holds(Parent, field(numChildren,Kids), S), Kids > 2.

% if exactly two kids, then delete Child1 too
deleteChild(Parent, Child1, S) 					:- contractNodes(Parent, Child1, Child2, NewValue, S),
													holds(Parent, field(numChildren,2), S).
inheritFromAndDelete(Parent, NewValue, S)		:- contractNodes(Parent, Child1, Child2, NewValue, S),
													holds(Parent, field(numChildren,2), S).

inheritFrom(Parent, SecondKid, S)				:- inheritFromAndDelete(Parent, SecondKid, S).
deleteChild(Parent, SecondKid, S) 				:- inheritFromAndDelete(Parent, SecondKid, S).

% 						### REMOVING A SINGLE FIELD
%--------------------------------------------------------------------------------
removed(ID, field(fieldName, Value), S) :- deleteField(ID, fieldName, S), holds(ID, field(fieldName, Value), S).

% 						### REMOVING/ADDING numer/denom FIELDS
%--------------------------------------------------------------------------------
deleteField(ID, numer, S) 				:- deleteFracFields(ID,S).
deleteField(ID, denom, S) 				:- deleteFracFields(ID,S).

assigned(ID, field(numer, Num), S)		:- addFracFields(ID, Num, Denom, S).
assigned(ID, field(denom, Denom), S) 	:- addFracFields(ID, Num, Denom, S).

% 						### CONVERT MONOMIAL TO OPERATOR NODE AND ADD CHILDREN
%--------------------------------------------------------------------------------
% ... conversion part
delete(ID, S) 									:-	convertToOperWithKids(ID, Oper, NumKids, S).	% delete old fields
assigned(ID, field(type, poly), S) 				:-	convertToOperWithKids(ID, Oper, NumKids, S).	% new fields
assigned(ID, field(nodeOper, Oper), S) 			:-	convertToOperWithKids(ID, Oper, NumKids, S).
assigned(ID, field(numChildren, NumKids), S) 	:-	convertToOperWithKids(ID, Oper, NumKids, S).
assigned(ID, field(side, Side), S) 				:-	convertToOperWithKids(ID, Oper, NumKids, S), 
													holds(ID, field(side, Side), S).
makeChildrenFor(ID, NumKids, S) 				:-	convertToOperWithKids(ID, Oper, NumKids, S).

% ... child creation part
% 		NOTE: does not fill in any field data for the children
newKidOnTheBlock(ID, ID*max_terms + KidNum, S) :- makeChildrenFor(ID, NumKids, S), KidNum = 1..NumKids .
assigned(Parent, field(parentOf, KidID), S) :- newKidOnTheBlock(Parent, KidID, S).

% 						### MISC HELPERS
%--------------------------------------------------------------------------------
sameDeg(N1, N2, S) 	:- 	holds(N1, field(nodeDeg, Deg), S), 
						holds(N2, field(nodeDeg, Deg), S),
						node(N1),
						node(N2),
						degree(Deg).
sameCoef(N1, N2, S) :-	holds(N1, field(nodeCoef, Coef), S), 
						holds(N2, field(nodeCoef, Coef), S), 
						node(N1),
						N1 != one,
						N1 != temp,
						N2 != one,
						N2 != temp,
						node(N2),
						coeffValue(Coef).
equalMonom(C1, C2, S)	:-	step(S),
							sameCoef(C1, C2, S),
							sameDeg(C1, C2, S).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% RULE SELECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% possible actions:
%	each possible action is valid at a particular point in time
%	possible(action, S)
%
%	TODO: need a convenient way to factor out the actions that will be done if
%	a candidate action is selected
%
%   for every possible action, we select one action to be performed
% 	then for the performed action, we follow the required steps



% do no more than one action per time step
0 { _selected(Action, S) : possible(Action, S) } 1 :- step(S).

% avoid no-ops between rule applications. All rule applications happen first.
actionforStep(S) :- _selected(Action,S).
:- step(S), step(S+1), not actionforStep(S), actionforStep(S+1).



% project just on the action name, as opposed to the specific terms the action applies to. 
% later, can project on action occuring at a particular time step: action(Name, Step)
action(Name) :- _selected(action(X,Name), S).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% AN EQN IS SOLVED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%_contradiction	:- 	step(S), 
%					holds(1, field(nodeCoef,A), S),
%					holds(1, field(nodeDeg, 0), S),
%					holds(2, field(nodeCoef,B), S),
%					holds(2, field(nodeDeg, 0), S),
%					coeffValue(A),
%					coeffValue(B),
%					A != B.
%					
%
%_solved :- step(S), 
%		holds(1, field(nodeCoef,1), S),
%		holds(1, field(nodeDeg, 1), S),
%		holds(1, field(side, left), S),
%		holds(2, field(nodeDeg, 0), S),
%		holds(2, field(side, right), S).
%
%:- not _solved.
%:- _contradiction.
%const(ID) :- type(ID, mono), nodeDeg(ID, 0) .
%:- 3 {const(ID) : node(ID) } .


% TODO: remove this is just for testing:
_node(N)              	:-	node(N).              
_type(ID,T)           	:-	type(ID,T).           
_nodeOper(ID,Op)		:-	nodeOper(ID,Op).     
_numChildren(ID,Num) 	:-	numChildren(ID,Num). 
_parentOf(PID, CID)   	:-	parentOf(PID, CID).   
_side(ID, S)          	:-	side(ID, S).          
_depth(ID, D)         	:-	depth(ID, D).         
_nodeCoef(ID, C)     	:-	nodeCoef(ID, C).     
_nodeDeg(ID, D)      	:-	nodeDeg(ID, D).      


% TODO: remove. Used by eqn visualizer
_type(ID,T, S)				:-	holds(ID, field(type,T), S).			
_nodeOper(ID,Op, S)			:-	holds(ID, field(nodeOper,Op), S).		
_numChildren(ID,Num, S)		:-	holds(ID, field(numChildren,Num), S).	
_parentOf(ID, CID, S)		:-	holds(ID, field(parentOf,CID), S).	
_side(ID, S, S)				:-	holds(ID, field(side,S), S).			
_depth(ID, D, S)			:-	holds(ID, field(depth,D), S).			
_nodeCoef(ID, C, S)			:-	holds(ID, field(nodeCoef,C), S).		
_nodeDeg(ID, D, S)			:-	holds(ID, field(nodeDeg,D), S).		
_numer(ID, D, S)			:-	holds(ID, field(numer,D), S).		
_denom(ID, D, S)			:-	holds(ID, field(denom,D), S).		

%#show holds/2.
%#show action/1.
#show action/1.
%#show _node/1.
%#show _type/2.
%#show _nodeOper/2.
%#show _numChildren/2.
%#show _parentOf/2.
%#show _side/2.
%#show _depth/2.
%#show _nodeCoef/2.
%#show _nodeDeg/2.

% used for eqn solver steps
#show _type/3.
#show _nodeOper/3.
#show _numChildren/3.
#show _parentOf/3.
%#show _side/3.
%#show _depth/3.
#show _nodeCoef/3.
#show _nodeDeg/3.
#show _numer/3.
#show _denom/3.

